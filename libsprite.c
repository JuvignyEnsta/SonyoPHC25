// Library sprite pour le PHC 25
#include <stdint.h>
#include <string.h>
#define SPRITE_WIDTH  12
#define SPRITE_HEIGHT 16
#define FRAME_SIZE   ( (SPRITE_WIDTH * SPRITE_HEIGHT) / 4 )
#define SPRITE_SIZE  (SPRITE_WIDTH * SPRITE_HEIGHT)
#define NB_OF_SPRITES 10
#define ERROR         -1
#define SUCCESS        0

typedef unsigned char uchar;

typedef struct SpriteStruct
{
    unsigned char  id;
    unsigned short coords;
    unsigned char  user;
} Sprite;

uchar sprites[] =
{
3,0,0,3,0,0,15,192,0,15,192,0,14,192,0,56,176,0,48,176,0,60,240,0,255,252,0,47,224,0,27,144,0,22,80,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,192,0,0,192,0,3,240,0,3,240,0,3,176,0,14,44,0,12,44,0,15,60,0,63,255,0,11,248,0,6,228,0,5,148,0,0,64,0,0,0,0,0,0,0,0,0,0,
0,48,0,0,48,0,0,252,0,0,252,0,0,236,0,3,139,0,3,11,0,3,207,0,15,255,192,2,254,0,1,185,0,1,101,0,0,16,0,0,0,0,0,0,0,0,0,0,
0,12,0,0,12,0,0,63,0,0,63,0,0,59,0,0,226,192,0,194,192,0,243,192,3,255,240,0,191,128,0,110,64,0,89,64,0,4,0,0,0,0,0,0,0,0,0,0,
240,15,0,207,243,0,13,112,0,12,48,0,15,240,0,2,128,0,3,192,0,3,192,0,13,112,0,0,0,0,3,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
60,3,192,51,252,192,3,92,0,3,12,0,3,252,0,0,160,0,0,240,0,0,240,0,3,92,0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
15,0,240,12,255,48,0,215,0,0,195,0,0,255,0,0,40,0,0,60,0,0,60,0,0,215,0,0,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,192,60,3,63,204,0,53,192,0,48,192,0,63,192,0,10,0,0,15,0,0,15,0,0,53,192,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
47,128,0,191,224,0,138,32,0,218,112,0,138,32,0,32,128,0,10,0,0,32,128,0,10,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
11,224,0,47,248,0,34,136,0,54,156,0,34,136,0,8,32,0,2,128,0,8,32,0,2,128,0,0,0,0,2,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,248,0,11,254,0,8,162,0,13,167,0,8,162,0,2,8,0,0,160,0,2,8,0,0,160,0,0,0,0,0,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,190,0,2,255,128,2,40,128,3,105,192,2,40,128,0,130,0,0,40,0,0,130,0,0,40,0,0,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
10,0,0,47,128,0,176,224,0,224,176,0,224,176,0,197,48,0,197,48,0,224,176,0,224,176,0,176,224,0,47,128,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,8,136,0,8,136,0,2,224,0,2,224,0,11,120,0,11,120,0,2,224,0,2,224,0,8,136,0,8,136,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,160,0,2,248,0,11,14,0,14,11,0,14,11,0,12,83,0,12,83,0,14,11,0,14,11,0,11,14,0,2,248,0,0,160,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,136,128,0,136,128,0,46,0,0,46,0,0,183,128,0,183,128,0,46,0,0,46,0,0,136,128,0,136,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
160,10,0,170,170,0,175,250,0,191,254,0,35,200,0,41,104,0,45,120,0,8,32,0,11,224,0,11,224,0,2,128,0,2,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
40,2,128,42,170,128,43,254,128,47,255,128,8,242,0,10,90,0,11,94,0,2,8,0,2,248,0,2,248,0,0,160,0,0,160,0,0,0,0,0,0,0,0,0,0,0,0,0,
10,0,160,10,170,160,10,255,160,11,255,224,2,60,128,2,150,128,2,215,128,0,130,0,0,190,0,0,190,0,0,40,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,128,40,2,170,168,2,191,232,2,255,248,0,143,32,0,165,160,0,181,224,0,32,128,0,47,128,0,47,128,0,10,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,0,0,42,128,0,42,128,0,42,192,0,42,64,0,42,64,0,10,0,0,32,128,0,10,0,0,10,0,0,32,128,0,33,128,0,32,128,0,16,64,0,0,0,0,0,0,0,
5,64,0,29,208,0,27,144,0,13,192,0,3,0,0,20,80,0,69,68,0,69,68,0,69,68,0,192,12,0,10,128,0,8,128,0,8,128,0,8,128,0,4,64,0,20,80,0,
0,0,0,16,0,0,20,5,64,29,29,0,31,125,0,31,244,0,7,180,0,1,164,0,23,189,0,127,255,64,125,125,80,116,29,0,16,4,0,64,4,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

struct SpriteTableStruct
{
    Sprite sprites[NB_OF_SPRITES];
} spriteTab;

void initSprtTab(void) __z88dk_fastcall
{
    for (int i = 0; i < NB_OF_SPRITES; i++)
    {
        spriteTab.sprites[i].id     = 0;
        spriteTab.sprites[i].coords = 0;
        spriteTab.sprites[i].user   = 0;
    }
}

#define IS_ACTIVE(i) spriteTab.sprites[i].id & 128 != 0
#define ACTIVATE     128

void undrawSprt(uchar i) __z88dk_fastcall
{
    if (IS_ACTIVE(i)) // 
    {
        uchar* screen_ptr = (uchar*)0x6000 + (spriteTab.sprites[i].coords >> 3);
        for (uchar j = 0; j < SPRITE_HEIGHT; ++j)
        {
            *screen_ptr = 0; // Clear the pixel at the sprite's coordinates
            ++screen_ptr;
            *screen_ptr = 0;
            ++screen_ptr;
            *screen_ptr = 0;
            screen_ptr += 30;
        }
    }
}

void undrawSprts(void) __z88dk_fastcall
{
    for (uchar i = 0; i < NB_OF_SPRITES; i++)
    {
        undrawSprt(i); // Call the function to undraw each sprite
    }
}


void drawSprts(void) __z88dk_fastcall
{
    for (uchar i = 0; i < NB_OF_SPRITES; i++)
    {
        if (IS_ACTIVE(i)) // Check if the sprite is active
        {
            uchar id = spriteTab.sprites[i].id & 0x0F;
            uchar* screen_ptr = (uchar*)0x6000 + (spriteTab.sprites[i].coords >> 3);

            uchar* sprite_ptr = sprites + id * SPRITE_SIZE + (spriteTab.sprites[i].coords & 3)*FRAME_SIZE;
            for (uchar j = 0; j < SPRITE_HEIGHT; ++j)
            {
                *screen_ptr |= *sprite_ptr; // Draw the sprite on the screen
                ++screen_ptr; ++sprite_ptr; // Move to the next block
                *screen_ptr |= *sprite_ptr;
                ++screen_ptr; ++sprite_ptr; // Move to the next block
                *screen_ptr |= *sprite_ptr;
                screen_ptr += 30;
                ++sprite_ptr; // Move to the next block
            }
        }
    }
}

#define SETPIXPOS(i, x, y) spriteTab.sprites[i].coords = ((y) << 5) + (x) 

uchar addSprt(uchar kind, uchar x, uchar y) 
{
    uchar i = 0;
    for (i = 0; (i < NB_OF_SPRITES) && (IS_ACTIVE(i)); ++i );
    if (i == NB_OF_SPRITES) return -1;
    spriteTab.sprites[i].id = kind | ACTIVATE;
    SETPIXPOS(i, x, y);
    return i;
}

